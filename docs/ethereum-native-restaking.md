# Ethereum Native Restaking for Exocore

## Overview

Native restaking is distinguished from LSD restaking with unique features: No LSD token is involved for native stakers to participate in the Exocore restaking.
Instead, all the restaker of Ethereum needs to do is:

1. create an ExoCapsule contract owned by the restaker itself through the Exocore gateway contract.
2. deposit 32 ETH to Ethereum beacon chain to become an activated validator, and point the withdrawal-credential(withdrawal address) to the ExoCapsule address created in the last step.
3. After restaker becomes an activated validator on beacon chain and before the restaker fully withdraws from beacon chain, deposit into Exocore by verifying  `ValidatorContainer`, included in the beacon chain block, with `ValidatorContainerProof`, generated by querying beacon chain node, against the beacon block root fetched from `BeaconRoot` contract(proposed by EIP4788 and enabled in the latest Dencun upgrade).
4. After restaker deposits into Exocore and before the restaker fully withdraws from beacon chain, restaker's effective balance as a beacon chain validator may change owing to rewards, penalties and even slashing. So restaker's balance inside of Exocore needs to be updated when it comes to these scenarios. This is done by verifying the latest `ValidatorContainer` to update restaker's balance.
5. After restaker deposits into Exocore and before the restaker fully withdraws from beacon chain, restaker's effective balance as a beacon chain validator is capped at 32 ETH, and the exceeding part would be automatically sent to the withdrawal address, which is the restaker's ExoCapsule address. This is called partial withdrawal, and restaker could claim this part from owned ExoCapsule to restaker's address by verifying the `WithdrawalContainer`, which is included as `ExecutionPayload` in beacon block, with `WithdrawalProof` generated by querying node, against the beacon block root fetched from `BeaconRoot` contract(proposed by EIP4788 and enabled in the latest Dencun upgrade).
6. After restaker fully withdraws from beacon chain and these assets are unbounded from operators on Exocore network, restaker could fully exits its native restaked ETH from Exocore by:
   1. verifying the latest `ValidateContainer` has `withdrawableEpoch` set(empty value is type(uint64).max) and current block timestamp exceeds the `withdrawableEpoch`.
   2. verifying the `WithdrawalContainer`, which is included as `ExecutionPayload` in beacon block, with `WithdrawalProof` generated by querying node, against the beacon block root fetched from `BeaconRoot` contract(proposed by EIP4788 and enabled in the latest Dencun upgrade).

## Ethereum Beacon Chain Proof

### Data Structures

`BeaconBlock` container is the most high level data structure involved in verifying the inclusion proof of specific beacon state data, so ordinally we verify expected data fields against the beacon block root hash. After Dencun upgrade(already activated on Ethereum mainnet), EIP4788 is activated and a beacon root contract is deployed to allow smart contracts fetching beacon block root at specific timestamp.

```
class BeaconBlock(Container):
    slot: Slot
    proposer_index: ValidatorIndex
    parent_root: Root
    state_root: Root
    body: BeaconBlockBody
```

`BeaconBlockHeader` container is the `BeaconBlock` Lite, with same fields except `BeaconBlockBody` is included as `BodyRoot` instead of actual `BeaconBlockBody` container.

```
class BeaconBlockHeader(Container):
    slot: Slot
    proposer_index: ValidatorIndex
    parent_root: Root
    state_root: Root
    body_root: Root
```

`BeaconBlockBody` container contains the block data `execution_payload` that should be applied to generate new `BeaconState`.

```
class BeaconBlockBody(Container):
    randao_reveal: BLSSignature
    eth1_data: Eth1Data  # Eth1 data vote
    graffiti: Bytes32  # Arbitrary data
    # Operations
    proposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]
    attester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]
    attestations: List[Attestation, MAX_ATTESTATIONS]
    deposits: List[Deposit, MAX_DEPOSITS]
    voluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]
    sync_aggregate: SyncAggregate
    # Execution
    execution_payload: ExecutionPayload
    # Capella operations
    bls_to_execution_changes: List[SignedBLSToExecutionChange, MAX_BLS_TO_EXECUTION_CHANGES]  # [New in Capella]
```

`ExecutionPayload` container is included in `BeaconBlockBody` and it contains block transactions as well as beacon chain withdrawals.

```
class ExecutionPayload(Container):
    # Execution block header fields
    parent_hash: Hash32
    fee_recipient: ExecutionAddress  # 'beneficiary' in the yellow paper
    state_root: Bytes32
    receipts_root: Bytes32
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    prev_randao: Bytes32  # 'difficulty' in the yellow paper
    block_number: uint64  # 'number' in the yellow paper
    gas_limit: uint64
    gas_used: uint64
    timestamp: uint64
    extra_data: ByteList[MAX_EXTRA_DATA_BYTES]
    base_fee_per_gas: uint256
    # Extra payload fields
    block_hash: Hash32  # Hash of execution block
    transactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]
    withdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]  # [New in Capella]
```

`Withdrawal` container is included in `ExecutionPayload` container and it includes validator's withdrawal information like `validator_index` that indicates specific validator's index in the `BeaconState`'s `validators` list. `Withdrawal` container is used for verifying partial or fully withdrawal of specific validator in native restaking scenary.

```
class Withdrawal(Container):
    index: WithdrawalIndex
    validator_index: ValidatorIndex
    address: ExecutionAddress
    amount: Gwei
```

`BeaconState` container is included as `stete_root` inside `BeaconBlock` and it includes all the beacon chain state variables, especially all registered validators for `validators`.

```
class BeaconState(Container):
    class BeaconState(Container):
    # Versioning
    genesis_time: uint64
    genesis_validators_root: Root
    slot: Slot
    fork: Fork
    # History
    latest_block_header: BeaconBlockHeader
    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    historical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]  # Frozen in Capella, replaced by historical_summaries
    # Eth1
    eth1_data: Eth1Data
    eth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]
    eth1_deposit_index: uint64
    # Registry
    validators: List[Validator, VALIDATOR_REGISTRY_LIMIT]
    balances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]
    # Randomness
    randao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]
    # Slashings
    slashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances
    # Participation
    previous_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    current_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    # Finality
    justification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch
    previous_justified_checkpoint: Checkpoint
    current_justified_checkpoint: Checkpoint
    finalized_checkpoint: Checkpoint
    # Inactivity
    inactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]
    # Sync
    current_sync_committee: SyncCommittee
    next_sync_committee: SyncCommittee
    # Execution
    latest_execution_payload_header: ExecutionPayloadHeader  # [Modified in Capella]
    # Withdrawals
    next_withdrawal_index: WithdrawalIndex  # [New in Capella]
    next_withdrawal_validator_index: ValidatorIndex  # [New in Capella]
    # Deep history valid from Capella onwards
    historical_summaries: List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]  # [New in Capella]
```

`Validator` container is included in `BeaconState` as a list, and it includes validator's properties like `pubkey`, `withdrawal_credentials`, `effective_balance`, `withdrawal_epoch` and so on. `Validator` container is used in various scenarios like `ExoCapsule.deposit`, `ExoCapsule.updateStakeBalance` and `ExoCapsule.withdraw` to verify validator's information and update validator's staking balance.

```
class Validator(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32  # Commitment to pubkey for withdrawals
    effective_balance: Gwei  # Balance at stake
    slashed: boolean
    # Status epochs
    activation_eligibility_epoch: Epoch  # When criteria for activation were met
    activation_epoch: Epoch
    exit_epoch: Epoch
    withdrawable_epoch: Epoch  # When validator can withdraw funds
```

### Beacon Block Data Merklelization

Beacon block root is the merkle root hash of the `BeaconBlock`. The merklelization of `BeaconBlock` is done recursively from the most underlying data fields to containers until the most high level `BeaconBlock`. The whole serialization and merklelization process follow the [`SSZ` rules](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md).

Most important rules related to native restaking merkle proof are:

1. `merkleize(pack(value))` if value is a basic object or a vector of basic objects.
2. `merkleize([hash_tree_root(element) for element in value])` if value is a vector of composite objects or a container.
3. `mix_in_length(merkleize([hash_tree_root(element) for element in value], limit=chunk_count(type)), len(value))` if value is a list of composite objects, where `mix_in_length` means: Given a Merkle root `root` and a length `length` ("uint256" little-endian serialization) return `hash(root + length)`.

Take `Validator` container as example: `Validator` container is merklelized by:

1. serializing container fields into chunks of `bytes32` and using them as merkle tree leafs.
2. dividing leafs into pairs in order, the missing leafs would be replaces by zero `bytes32`.
3. hashing all the pairs to get new leafs, and recursively doing this until there exists only one hash, which is the root hash of `Validator` container.

Given `BeaconState` include a list of `Validator` containers as `validators` field, so `Validator` containers roots are first merklelized to get a root hash, and then this root hash with the `validators` length together is hashed to get the real root hash of `validators` field.

